#!/usr/bin/env node

require('dotenv').config();
const { program } = require('commander');
const fs = require('fs');
const path = require('path');
const MarkdownIt = require('markdown-it');
const mdAnchor = require('markdown-it-anchor');
const mdTable = require('markdown-it-multimd-table');
const puppeteer = require('puppeteer');
const slug = require('slug');
const chokidar = require('chokidar');
const express = require('express');
const WebSocket = require('ws');
const multer = require('multer');
const os = require('os');
const OpenAI = require('openai');
const crypto = require('crypto');

const PRESET_DIR = process.env.PRESENT_STORAGE_DIR || path.join(os.homedir(), '.preset');
const LOCK_METADATA_FILE = path.join(PRESET_DIR, 'file_locks.json');

// ÏÑ∏ÏÖòÎ≥Ñ ÏûÑÏãú Ï†ëÍ∑º Í∂åÌïú Ï†ÄÏû• (Î©îÎ™®Î¶¨)
const temporaryAccess = new Map(); // sessionId -> Set(filenames)

// OpenAI ÏÑ§Ï†ï
const openai = process.env.OPENAI_API_KEY ? new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
}) : null;

// package.jsonÏóêÏÑú Î≤ÑÏ†Ñ ÏùΩÍ∏∞
const packageJson = require('./package.json');

program
  .version(packageJson.version)
  .description('A markdown presentation tool with web and CLI modes.')
  .option('--md <path>', 'Path to the input markdown file (CLI mode)')
  .option('--template <path>', 'Path to the HTML template file (CLI mode)', 'template.html')
  .option('--output <path>', 'Path for the output HTML file (CLI mode)', 'output.html')
  .option('--pdf', 'Generate a PDF file from the output (CLI mode)')
  .option('--web', 'Run in web server mode')
  .option('--port <number>', 'Port for the web server', '8090')
  .parse(process.argv);

const options = program.opts();

// --- Helper Functions ---

function createMarkdownParser() {
  const toc = [];
  const md = new MarkdownIt({ html: true })
    .use(mdAnchor, {
      slugify: s => slug(s, { lower: true }),
      callback: (token, { slug, title }) => {
        if (token.tag === 'h1' || token.tag === 'h2' || token.tag === 'h3') {
          toc.push({ level: parseInt(token.tag.substring(1)), slug: slug, title: title });
        }
      }
    })
    .use(mdTable, {
      multiline: true,
      rowspan: true,
      headerless: true,
      multibody: true
    });
  return { md, toc };
}

function generateTocHtml(toc) {
  let html = '<ul>';
  toc.forEach(item => {
    html += `<li class="toc-level-${item.level}"><a href="#${item.slug}">${item.title}</a></li>`;
  });
  html += '</ul>';
  return html;
}

// --- CLI Mode ---

async function runCli(options) {
  const { md: mdPath, template: templatePath, output: outputPath, pdf: createPdf } = options;

  if (!fs.existsSync(mdPath)) {
    console.error(`Error: Markdown file not found at ${mdPath}`);
    process.exit(1);
  }
  if (!fs.existsSync(templatePath)) {
    console.error(`Error: Template file not found at ${templatePath}`);
    process.exit(1);
  }

  const markdownContent = fs.readFileSync(mdPath, 'utf8');
  const templateContent = fs.readFileSync(templatePath, 'utf8');
  
  const { md, toc } = createMarkdownParser();
  const contentHtml = md.render(markdownContent);
  const tocHtml = generateTocHtml(toc);

  const bodyClass = createPdf ? 'export-mode pdf-export-mode' : 'export-mode';
  let finalHtml = templateContent
    .replace('{{TOC_HTML}}', tocHtml)
    .replace('{{CONTENT}}', contentHtml)
    .replace('<body>', `<body class="${bodyClass}">`) // Use export styles
    .replace(
        '</body>',
        '<script>window.IS_EXPORTED=true;</script></body>'
    );

  if (createPdf) {
    // PDF Î™®ÎìúÏóêÏÑúÎäî HTML ÌååÏùºÏùÑ Ï†ÄÏû•ÌïòÏßÄ ÏïäÍ≥† ÏßÅÏ†ë PDF ÏÉùÏÑ±
    const browser = await puppeteer.launch({ headless: "new" });
    const page = await browser.newPage();
    
    // HTML ÏΩòÌÖêÏ∏†Î•º ÏßÅÏ†ë ÏÑ§Ï†ï (ÌååÏùº Ï†ÄÏû• ÏóÜÏù¥)
    await page.setContent(finalHtml, { waitUntil: 'networkidle0' });
    
    // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å ÎåÄÍ∏∞
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const pdfOutputPath = outputPath.replace(/\.html$/, '.pdf');
    await page.pdf({ path: pdfOutputPath, format: 'A4', printBackground: false });
    await browser.close();
    console.log(`Successfully generated PDF file at: ${pdfOutputPath}`);
  } else {
    // HTML Î™®ÎìúÏóêÏÑúÎßå HTML ÌååÏùº Ï†ÄÏû•
    fs.writeFileSync(outputPath, finalHtml, 'utf8');
    console.log(`Successfully generated HTML file at: ${outputPath}`);
  }
}

// --- Web Server Mode ---

function serveApp(options) {
  // Ensure .preset directory exists for web mode
  if (!fs.existsSync(PRESET_DIR)) {
    fs.mkdirSync(PRESET_DIR);
  }

  const storage = multer.diskStorage({
    destination: (req, file, cb) => cb(null, PRESET_DIR),
    filename: (req, file, cb) => cb(null, file.originalname)
  });
  const upload = multer({ storage: storage });

  const port = parseInt(options.port, 10);
  const app = express();
  app.use(express.json());
  app.use(express.static(__dirname));
  
  // ÏÑ∏ÏÖò Í¥ÄÎ¶¨Î•º ÏúÑÌïú Í∞ÑÎã®Ìïú ÏÑ∏ÏÖò ID ÏÉùÏÑ±
  function generateSessionId() {
    return crypto.randomBytes(32).toString('hex');
  }
  
  // Ïø†ÌÇ§ ÌååÏÑú ÎØ∏Îì§Ïõ®Ïñ¥
  app.use((req, res, next) => {
    req.cookies = {};
    const cookieHeader = req.headers.cookie;
    if (cookieHeader) {
      cookieHeader.split(';').forEach(cookie => {
        const [name, value] = cookie.trim().split('=');
        req.cookies[name] = value;
      });
    }
    next();
  });
  
  // ÏÑ∏ÏÖò ID ÎØ∏Îì§Ïõ®Ïñ¥
  app.use((req, res, next) => {
    if (!req.cookies.sessionId) {
      req.sessionId = generateSessionId();
      res.setHeader('Set-Cookie', `sessionId=${req.sessionId}; HttpOnly; Path=/; Max-Age=86400`);
    } else {
      req.sessionId = req.cookies.sessionId;
    }
    next();
  }); 
  // ÎßàÌÅ¨Îã§Ïö¥ ÌååÏùº ÏßÅÏ†ë Ï†ëÍ∑º Ï†úÌïú ÎØ∏Îì§Ïõ®Ïñ¥
  app.use('/storage', (req, res, next) => {
    if (req.path.endsWith('.md')) {
      return res.status(403).json({ 
        error: 'Direct access to markdown files is not allowed. Use /api/get-file endpoint instead.' 
      });
    }
    next();
  });
  
  app.use('/storage', express.static(PRESET_DIR)); 

  app.get('/', (req, res) => {
    const files = fs.readdirSync(PRESET_DIR).filter(file => file.endsWith('.md'));
    const lockMetadata = loadFileLockMetadata();
    
    let fileList = files.map(file => {
      const isLocked = lockMetadata[file] && lockMetadata[file].isLocked;
      const lockIcon = isLocked ? '<span style="color: #ff6b35; margin-left: 8px;">üîí</span>' : '';
      const lockClass = isLocked ? 'locked-file' : '';
      
      return `<li class="${lockClass}">
        <a href="/view?file=${file}">${file}</a>${lockIcon}
        ${isLocked ? '<span style="color: #666; font-size: 12px; margin-left: 8px;">(Ïû†ÍπÄ)</span>' : ''}
      </li>`;
    }).join('');
    
    res.send(`
      <!DOCTYPE html>
      <html>
      <head><title>Presentations</title>
        <style>
          body { font-family: sans-serif; padding: 2em; } 
          .container { max-width: 800px; margin: auto; }
          ul { list-style: none; padding: 0; } 
          li { padding: 0.8em; border-bottom: 1px solid #eee; display: flex; align-items: center; }
          li.locked-file { background-color: #fff8f0; border-left: 3px solid #ff6b35; }
          a { text-decoration: none; color: #0366d6; flex-grow: 1; }
          a:hover { text-decoration: underline; }
          .actions { margin-top: 2em; display: flex; gap: 1em; }
          .actions form { display: flex; gap: 0.5em; }
          .actions input[type="file"], .actions input[type="text"] { padding: 0.3em; }
          .actions button { padding: 0.3em 0.8em; background: #0366d6; color: white; border: none; border-radius: 3px; cursor: pointer; }
          .actions button:hover { background: #0256cc; }
        </style>
      </head>
      <body>
        <div class="container">
          <h1>üìÑ Presentations</h1>
          <ul>${fileList}</ul>
          <div class="actions">
            <form action="/upload" method="post" enctype="multipart/form-data">
              <input type="file" name="markdown" accept=".md" required>
              <button type="submit">üì§ Upload</button>
            </form>
            <form action="/create" method="post">
              <input type="text" name="filename" placeholder="new-presentation.md" required>
              <button type="submit">‚ûï Create New</button>
            </form>
          </div>
        </div>
      </body>
      </html>
    `);
  });

  app.get('/view', (req, res) => {
    const file = req.query.file;
    if (!file || !fs.existsSync(path.join(PRESET_DIR, file))) {
      return res.status(404).send('File not found.');
    }
    
    // Ïõπ Î™®ÎìúÏóêÏÑúÎäî Îπà templateÏùÑ Î≥¥ÎÇ¥Í≥† JavaScriptÏóêÏÑú ÎèôÏ†ÅÏúºÎ°ú ÏΩòÌÖêÏ∏† Î°úÎìú
    const templatePath = path.join(__dirname, 'template.html');
    let templateContent = fs.readFileSync(templatePath, 'utf8');
    
    // ÌîåÎ†àÏù¥Ïä§ÌôÄÎçîÎ•º Îπà Í∞íÏúºÎ°ú ÏπòÌôò (JavaScriptÏóêÏÑú ÎèôÏ†ÅÏúºÎ°ú Ï±ÑÏö∏ ÏòàÏ†ï)
    templateContent = templateContent
      .replace('{{CONTENT}}', '')
      .replace('{{TOC_HTML}}', '');
    
    res.send(templateContent);
  });

  app.post('/upload', upload.single('markdown'), (req, res) => {
    console.log(`Uploaded: ${req.file.filename}`);
    res.redirect('/');
  });

  app.post('/create', express.urlencoded({ extended: true }), (req, res) => {
    let filename = req.body.filename;
    if (!filename.endsWith('.md')) filename += '.md';
    const filepath = path.join(PRESET_DIR, filename);
    if (!fs.existsSync(filepath)) {
      fs.writeFileSync(filepath, '# New Presentation\n\nStart writing here.', 'utf8');
      console.log(`Created: ${filename}`);
    }
    res.redirect('/');
  });

  app.post('/api/render', (req, res) => {
    try {
      const { markdown } = req.body;
      if (typeof markdown !== 'string') return res.status(400).json({ error: 'Invalid content.' });
      const { md, toc } = createMarkdownParser();
      const contentHtml = md.render(markdown);
      const tocHtml = generateTocHtml(toc);
      res.json({ contentHtml, tocHtml });
    } catch (error) {
      console.error('Error in /api/render:', error);
      res.status(500).json({ error: 'Server failed to render markdown.' });
    }
  });

  app.post('/save-md', (req, res) => {
    const { content, file } = req.body;
    if (typeof content !== 'string' || !file) return res.status(400).send('Invalid request.');
    
    // ÌååÏùº Ïû†Í∏à ÏÉÅÌÉú ÌôïÏù∏
    const metadata = loadFileLockMetadata();
    const fileMetadata = metadata[file];
    
    // ÏÑ∏ÏÖòÎ≥Ñ ÏûÑÏãú Ï†ëÍ∑º Í∂åÌïú ÌôïÏù∏
    const sessionAccess = temporaryAccess.get(req.sessionId) || new Set();
    const hasTemporaryAccess = sessionAccess.has(file);
    
    if (fileMetadata && fileMetadata.isLocked && !hasTemporaryAccess) {
      return res.status(403).json({ error: 'File is locked. Please unlock it first.' });
    }
    
    fs.writeFile(path.join(PRESET_DIR, file), content, 'utf8', (err) => {
      if (err) return res.status(500).send('Error saving file.');
      res.status(200).send('File saved.');
    });
  });

  // ÌååÏùº ÎÇ¥Ïö© Í∞ÄÏ†∏Ïò§Í∏∞ (Ïû†Í∏à ÏÉÅÌÉú ÌôïÏù∏ Ìè¨Ìï®)
  app.get('/api/get-file', (req, res) => {
    try {
      const { filename } = req.query;
      console.log('ÌååÏùº ÏöîÏ≤≠:', { filename, sessionId: req.sessionId });
      
      if (!filename) {
        return res.status(400).json({ error: 'Filename is required' });
      }

      const filePath = path.join(PRESET_DIR, filename);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
      }

      // ÌååÏùº Ïû†Í∏à ÏÉÅÌÉú ÌôïÏù∏
      let metadata = {};
      try {
        if (fs.existsSync(LOCK_METADATA_FILE)) {
          const data = fs.readFileSync(LOCK_METADATA_FILE, 'utf8');
          metadata = JSON.parse(data);
        }
      } catch (error) {
        console.error('ÌååÏùº Ïû†Í∏à Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú Ïò§Î•ò:', error);
      }
      
      const fileMetadata = metadata[filename];
      
      // ÏÑ∏ÏÖòÎ≥Ñ ÏûÑÏãú Ï†ëÍ∑º Í∂åÌïú ÌôïÏù∏
      const sessionAccess = temporaryAccess.get(req.sessionId) || new Set();
      const hasTemporaryAccess = sessionAccess.has(filename);
      
      if (fileMetadata && fileMetadata.isLocked && !hasTemporaryAccess) {
        // Ïû†Í∏¥ ÌååÏùºÏùò Í≤ΩÏö∞ ÎπÑÎ∞ÄÎ≤àÌò∏ ÏûÖÎ†• UI Î∞òÌôò
        return res.json({ 
          content: '', 
          isLocked: true, 
          needsPassword: true,
          filename: filename
        });
      }

      // Ïû†Í∏∞ÏßÄ ÏïäÏùÄ ÌååÏùºÏù¥Í±∞ÎÇò ÏûÑÏãú Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏûàÎäî Í≤ΩÏö∞ Ïã§Ï†ú ÎÇ¥Ïö© Î∞òÌôò
      const content = fs.readFileSync(filePath, 'utf8');
      res.json({ content: content, isLocked: false });
      
    } catch (error) {
      console.error('Error in /api/get-file:', error);
      res.status(500).json({ error: 'Failed to load file' });
    }
  });

  // ÏûÑÏãú Ï†ëÍ∑º Í∂åÌïú Î∂ÄÏó¨ (ÎπÑÎ∞ÄÎ≤àÌò∏ ÌôïÏù∏)
  app.post('/api/temporary-access', (req, res) => {
    try {
      const { filename, password } = req.body;
      if (!filename || !password) {
        return res.status(400).json({ error: 'Filename and password are required' });
      }

      // ÌååÏùº Ïû†Í∏à Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú
      let metadata = {};
      try {
        if (fs.existsSync(LOCK_METADATA_FILE)) {
          const data = fs.readFileSync(LOCK_METADATA_FILE, 'utf8');
          metadata = JSON.parse(data);
        }
      } catch (error) {
        console.error('ÌååÏùº Ïû†Í∏à Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú Ïò§Î•ò:', error);
        return res.status(500).json({ error: 'Failed to load file metadata' });
      }

      const fileMetadata = metadata[filename];
      if (!fileMetadata || !fileMetadata.isLocked) {
        return res.status(400).json({ error: 'File is not locked' });
      }

      // ÎπÑÎ∞ÄÎ≤àÌò∏ ÌôïÏù∏
      function hashPassword(password, salt) {
        return crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');
      }
      
      const providedHash = hashPassword(password, fileMetadata.salt);
      if (providedHash !== fileMetadata.passwordHash) {
        return res.status(401).json({ error: 'Invalid password' });
      }

      // ÏÑ∏ÏÖòÏóê ÏûÑÏãú Ï†ëÍ∑º Í∂åÌïú Î∂ÄÏó¨
      if (!temporaryAccess.has(req.sessionId)) {
        temporaryAccess.set(req.sessionId, new Set());
      }
      temporaryAccess.get(req.sessionId).add(filename);

      res.json({ success: true, message: 'Temporary access granted' });
      
    } catch (error) {
      console.error('Error in /api/temporary-access:', error);
      res.status(500).json({ error: 'Failed to grant temporary access' });
    }
  });

  app.post('/export-pdf', async (req, res) => {
    try {
        const { markdown } = req.body;
        if (typeof markdown !== 'string') return res.status(400).send('Invalid content.');

        const { md, toc } = createMarkdownParser();
        const templatePath = path.resolve(__dirname, 'template.html');
        const templateContent = fs.readFileSync(templatePath, 'utf8');

        const htmlContent = md.render(markdown);
        const tocHtml = generateTocHtml(toc);

        let finalHtml = templateContent
            .replace('{{CONTENT}}', htmlContent)
            .replace('{{TOC_HTML}}', tocHtml);
        
        // Add a class to the body for PDF export to hide all interactive elements
        finalHtml = finalHtml.replace('<body>', '<body class="export-mode pdf-export-mode">');
        // Inject a flag to prevent client-side re-rendering in Puppeteer
        finalHtml = finalHtml.replace(
            '</body>',
            '<script>window.IS_PDF_EXPORT = true;</script></body>'
        );

        const browser = await puppeteer.launch({ headless: "new" });
        const page = await browser.newPage();
        
        await page.setContent(finalHtml, { waitUntil: 'networkidle0' });
        await new Promise(resolve => setTimeout(resolve, 1000));
        const pdfBuffer = await page.pdf({ format: 'A4', printBackground: false });
        await browser.close();

        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', 'attachment; filename=presentation.pdf');
        res.send(pdfBuffer);
    } catch (error) {
        console.error('Error exporting PDF:', error);
        res.status(500).send('Error generating PDF.');
    }
  });

  app.post('/api/ai-suggest', async (req, res) => {
    try {
      const { 
        text, 
        cursorPosition, 
        mode = 'continue', 
        selectedText = '', 
        apiKey = '',
        provider = 'openai',
        model = 'gpt-4o-mini',
        endpoint = '',
        customContinuePrompt = '',
        customImprovePrompt = ''
      } = req.body;
      
      console.log('\n=== AI Ï∂îÏ≤ú ÏöîÏ≤≠ ÏãúÏûë ===');
      console.log('üîß ÏöîÏ≤≠ Ï†ïÎ≥¥:', { 
        Î™®Îìú: mode,
        Ï†úÍ≥µÏûê: provider,
        Î™®Îç∏: model,
        Ï†ÑÏ≤¥Î¨∏ÏÑúÍ∏∏Ïù¥: text?.length,
        Ïª§ÏÑúÏúÑÏπò: cursorPosition,
        ÏÑ†ÌÉùÎêúÌÖçÏä§Ìä∏Í∏∏Ïù¥: selectedText?.length,
        APIÌÇ§ÏûàÏùå: !!apiKey
      });
      
      // ÎîîÎ≤ÑÍπÖÏö©: Ïª§ÏÑú ÏúÑÏπò ÌôïÏù∏
      const beforeCursorText = text.substring(0, cursorPosition);
      const afterCursorText = text.substring(cursorPosition);
      
      console.log('üìç Ïª®ÌÖçÏä§Ìä∏ Î∂ÑÏÑù:', {
        Ï†ÑÏ≤¥Î¨∏ÏÑúÎØ∏Î¶¨Î≥¥Í∏∞: text.length > 200 ? text.substring(0, 100) + '...' + text.substring(text.length - 100) : text,
        Ïª§ÏÑúÏïûÌÖçÏä§Ìä∏: beforeCursorText.slice(-100), // Ïª§ÏÑú Î∞îÎ°ú Ïïû 100Ïûê
        Ïª§ÏÑúÎí§ÌÖçÏä§Ìä∏: afterCursorText.slice(0, 100)  // Ïª§ÏÑú Î∞îÎ°ú Îí§ 100Ïûê
      });
      
      // API ÌÇ§Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
      if (!apiKey && !process.env.OPENAI_API_KEY) {
        console.log('API ÌÇ§Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏùå');
        const fallbackSuggestions = mode === 'improve' 
          ? ['Îçî Î™ÖÌôïÌïòÍ≤å ÌëúÌòÑ', 'Íµ¨Ï≤¥Ï†ÅÏù∏ ÏÑ§Î™Ö Ï∂îÍ∞Ä', 'Í∞ÑÍ≤∞ÌïòÍ≤å Ï†ïÎ¶¨']
          : ['Í≥ÑÏÜç ÏûëÏÑ±ÌïòÏÑ∏Ïöî...', 'Îçî ÏûêÏÑ∏Ìûà ÏÑ§Î™Ö', 'ÏòàÏãúÎ•º Ï∂îÍ∞Ä'];
        
        return res.status(400).json({ 
          error: 'API key required',
          suggestions: fallbackSuggestions
        });
      }
      
      // ÌòÑÏû¨Îäî OpenAIÏôÄ OpenAI Ìò∏Ìôò APIÎßå ÏßÄÏõê
      if (provider !== 'openai' && provider !== 'openai-compatible') {
        console.log(`ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Ï†úÍ≥µÏûê: ${provider}. OpenAIÎ°ú ÎåÄÏ≤¥Ìï©ÎãàÎã§.`);
        // Îã§Î•∏ Ï†úÍ≥µÏûêÎäî Ï∂îÌõÑ Íµ¨ÌòÑ
        const fallbackSuggestions = mode === 'improve' 
          ? ['Îçî Î™ÖÌôïÌïòÍ≤å ÌëúÌòÑ', 'Íµ¨Ï≤¥Ï†ÅÏù∏ ÏÑ§Î™Ö Ï∂îÍ∞Ä', 'Í∞ÑÍ≤∞ÌïòÍ≤å Ï†ïÎ¶¨']
          : ['Í≥ÑÏÜç ÏûëÏÑ±ÌïòÏÑ∏Ïöî...', 'Îçî ÏûêÏÑ∏Ìûà ÏÑ§Î™Ö', 'ÏòàÏãúÎ•º Ï∂îÍ∞Ä'];
        
        return res.json({ 
          suggestions: fallbackSuggestions,
          message: `${provider} Ï†úÍ≥µÏûêÎäî ÏïÑÏßÅ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§. OpenAIÎ•º ÏÇ¨Ïö©Ìï¥Ï£ºÏÑ∏Ïöî.`
        });
      }
      
      // OpenAI ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ï†ï
      let currentOpenai;
      if (provider === 'openai-compatible' && endpoint) {
        // OpenAI Ìò∏Ìôò API ÏÇ¨Ïö©
        currentOpenai = new OpenAI({ 
          apiKey: apiKey,
          baseURL: endpoint.endsWith('/v1') ? endpoint : endpoint + '/v1'
        });
      } else {
        // Í∏∞Î≥∏ OpenAI API ÏÇ¨Ïö©
        currentOpenai = apiKey ? new OpenAI({ apiKey }) : openai;
      }

      if (typeof text !== 'string' || typeof cursorPosition !== 'number') {
        return res.status(400).json({ error: 'Invalid request parameters.' });
      }

      const beforeCursor = text.substring(0, cursorPosition);
      const afterCursor = text.substring(cursorPosition);
      
      // Î™®ÎìúÏóê Îî∞Îùº Îã§Î•∏ ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
      let prompt;
      
      if (mode === 'improve') {
        // Í∞úÏÑ† Î™®Îìú ÌîÑÎ°¨ÌîÑÌä∏ (Ïª§Ïä§ÌÖÄ ÌîÑÎ°¨ÌîÑÌä∏Í∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©)
        const basePrompt = customImprovePrompt || `ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏Ï†ÅÏù∏ Í∏ÄÏì∞Í∏∞ ÎèÑÍµ¨ÏûÖÎãàÎã§. ÏÑ†ÌÉùÎêú ÌÖçÏä§Ìä∏Ïùò ÌïµÏã¨ ÏùòÎèÑÏôÄ Î©îÏãúÏßÄÎ•º Î≥¥Ï°¥ÌïòÎ©¥ÏÑú Îçî Ìö®Í≥ºÏ†ÅÏù∏ ÌëúÌòÑÏúºÎ°ú Í∞úÏÑ†Ìï¥Ï£ºÏÑ∏Ïöî.

<ÏÑ†ÌÉùÎêúÌÖçÏä§Ìä∏>
{selectedText}
</ÏÑ†ÌÉùÎêúÌÖçÏä§Ìä∏>

<Ï†ÑÏ≤¥Î¨∏ÏÑú>
{text}
</Ï†ÑÏ≤¥Î¨∏ÏÑú>

ÏúÑ Ï†ïÎ≥¥Î•º Ï∞∏Í≥†ÌïòÏó¨ ÏÑ†ÌÉùÎêú ÌÖçÏä§Ìä∏Î•º Í∞úÏÑ†Ìï¥Ï£ºÏÑ∏Ïöî. ÏõêÎ≥∏Ïùò ÏùòÎèÑÏôÄ Ìè¨Îß∑ÏùÑ Î∞òÎìúÏãú Ïú†ÏßÄÌïòÎ©¥ÏÑú Î¨∏Î≤ï, Î™ÖÌôïÏÑ±, ÌëúÌòÑÎ†•Îßå Í∞úÏÑ†Ìï¥Ï£ºÏÑ∏Ïöî.`;
        
        // Î≥ÄÏàò ÏπòÌôò (Ïª§Ïä§ÌÖÄ ÌîÑÎ°¨ÌîÑÌä∏Îì† Í∏∞Î≥∏ ÌîÑÎ°¨ÌîÑÌä∏Îì† Ìï≠ÏÉÅ ÏàòÌñâ)
        const userPrompt = basePrompt
          .replace(/{text}/g, text)
          .replace(/{selectedText}/g, selectedText)
          .replace(/{beforeCursor}/g, beforeCursor)
          .replace(/{afterCursor}/g, afterCursor);

        // Ìï≠ÏÉÅ ÎèôÏùºÌïú Íµ¨Ï°∞Î°ú ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ± (Ï∂úÎ†• ÌòïÏãù Î≥¥Ïû•)
        prompt = userPrompt + `

Í∏ÄÏì∞Í∏∞ Í∞úÏÑ† ÏßÄÏπ®:
1. **ÏõêÎ≥∏Ïùò ÏùòÎèÑÏôÄ ÌïµÏã¨ Î©îÏãúÏßÄÎ•º Ï†àÎåÄ Î≥ÄÍ≤ΩÌïòÏßÄ ÎßàÏÑ∏Ïöî**
2. **ÏõêÎ≥∏Í≥º ÎèôÏùºÌïú ÌÜ§, Î¨∏Ï≤¥, Í≤©Ïãù ÏàòÏ§ÄÏùÑ Ïú†ÏßÄ**ÌïòÏÑ∏Ïöî (Ï°¥ÎåìÎßê/Î∞òÎßê, Ïñ¥Ï°∞ Îì±)
3. **ÎßàÌÅ¨Îã§Ïö¥ Ìè¨Îß∑ÏùÑ ÏôÑÏ†ÑÌûà Î≥¥Ï°¥**ÌïòÏÑ∏Ïöî (Ìó§Îî©, Î¶¨Ïä§Ìä∏, ÍµµÍ∏∞, ÎßÅÌÅ¨ Îì±)
4. **ÏõêÎ≥∏Í≥º ÎπÑÏä∑Ìïú Í∏∏Ïù¥Î•º Ïú†ÏßÄ**ÌïòÎ©∞ Î¨∏Î≤ï, Î™ÖÌôïÏÑ±, ÌëúÌòÑÎ†•Îßå Í∞úÏÑ†ÌïòÏÑ∏Ïöî
5. **Î∂àÌïÑÏöîÌïú Ïû•ÏãùÏù¥ÎÇò Í≥ºÎèÑÌïú ÌëúÌòÑÏùÄ ÌîºÌïòÍ≥†** ÏûêÏó∞Ïä§ÎüΩÍ≤å Í∞úÏÑ†ÌïòÏÑ∏Ïöî
6. Ï†ÑÏ≤¥ Î¨∏ÏÑúÏùò **Îß•ÎùΩÍ≥º ÏùºÍ¥ÄÏÑ±**ÏùÑ Í≥†Î†§ÌïòÏó¨ Ï†ÅÏ†àÌïú ÏàòÏ§ÄÏúºÎ°ú Í∞úÏÑ†ÌïòÏÑ∏Ïöî
7. **3-5Í∞úÏùò Îã§ÏñëÌïú Í∞úÏÑ† Î≤ÑÏ†ÑÏùÑ Ï†úÍ≥µ**ÌïòÎêò, Î™®Îëê ÏõêÎ≥∏Ïùò ÏÑ±Í≤©ÏùÑ Ïú†ÏßÄÌï¥Ïïº Ìï©ÎãàÎã§
8. Î∞òÎìúÏãú ÏàúÏàò JSON Î∞∞Ïó¥ ÌòïÌÉúÎ°úÎßå Î∞òÌôòÌïòÏÑ∏Ïöî (ÏΩîÎìú Î∏îÎ°ùÏù¥ÎÇò ÏÑ§Î™Ö ÏóÜÏù¥)

ÏùëÎãµ ÌòïÏãù (Ïù¥ ÌòïÌÉú Í∑∏ÎåÄÎ°ú):
["Í∞úÏÑ†Îêú ÌëúÌòÑ 1", "Í∞úÏÑ†Îêú ÌëúÌòÑ 2", "Í∞úÏÑ†Îêú ÌëúÌòÑ 3", "Í∞úÏÑ†Îêú ÌëúÌòÑ 4", "Í∞úÏÑ†Îêú ÌëúÌòÑ 5"]`;
      } else {
        // Ïó∞ÏÜç ÏûëÏÑ± Î™®Îìú ÌîÑÎ°¨ÌîÑÌä∏ (Ïª§Ïä§ÌÖÄ ÌîÑÎ°¨ÌîÑÌä∏Í∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©)
        const basePrompt = customContinuePrompt || `ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏Ï†ÅÏù∏ Í∏ÄÏì∞Í∏∞ ÎèÑÍµ¨ÏûÖÎãàÎã§. Ïª§ÏÑú ÏúÑÏπòÏùò Íµ¨Ï°∞Ï†Å Îß•ÎùΩÏùÑ Ï†ïÌôïÌûà ÌååÏïÖÌïòÍ≥†, Í∑∏Ïóê ÎßûÎäî Ï†ÅÏ†àÌïú ÎÇ¥Ïö©ÏùÑ Ï†úÏïàÌï¥Ï£ºÏÑ∏Ïöî.

<Ïª§ÏÑúÏïûÎÇ¥Ïö©>
{beforeCursor}
</Ïª§ÏÑúÏïûÎÇ¥Ïö©>

<Ïª§ÏÑúÎí§ÎÇ¥Ïö©>
{afterCursor}
</Ïª§ÏÑúÎí§ÎÇ¥Ïö©>

<Ï†ÑÏ≤¥Î¨∏ÏÑú>
{text}
</Ï†ÑÏ≤¥Î¨∏ÏÑú>

ÏúÑ Ï†ïÎ≥¥Î•º Ï∞∏Í≥†ÌïòÏó¨ Ïª§ÏÑú ÏúÑÏπòÏóê Ï†ÅÏ†àÌïú ÎÇ¥Ïö©ÏùÑ Ï†úÏïàÌï¥Ï£ºÏÑ∏Ïöî. Ïª§ÏÑú Ïïû ÎÇ¥Ïö©Ïùò Íµ¨Ï°∞ÏôÄ Îß•ÎùΩÏùÑ Î©¥Î∞ÄÌûà Î∂ÑÏÑùÌïòÏó¨ Í∞ÄÏû• ÏûêÏó∞Ïä§Îü¨Ïö¥ ÌõÑÏÜç ÎÇ¥Ïö©ÏùÑ ÏÉùÏÑ±ÌïòÏÑ∏Ïöî.`;
        
        // Î≥ÄÏàò ÏπòÌôò (Ïª§Ïä§ÌÖÄ ÌîÑÎ°¨ÌîÑÌä∏Îì† Í∏∞Î≥∏ ÌîÑÎ°¨ÌîÑÌä∏Îì† Ìï≠ÏÉÅ ÏàòÌñâ)
        const userPrompt = basePrompt
          .replace(/{text}/g, text)
          .replace(/{beforeCursor}/g, beforeCursor)
          .replace(/{afterCursor}/g, afterCursor);

        // Ìï≠ÏÉÅ ÎèôÏùºÌïú Íµ¨Ï°∞Î°ú ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ± (Ï∂úÎ†• ÌòïÏãù Î≥¥Ïû•)
        prompt = userPrompt + `

Í∏ÄÏì∞Í∏∞ ÏßÄÏõê ÏßÄÏπ®:
1. **Ïª§ÏÑú ÏúÑÏπòÏùò Íµ¨Ï°∞Ï†Å Îß•ÎùΩÏùÑ Ï†ïÌôïÌûà ÌååÏïÖ**ÌïòÏÑ∏Ïöî:
   - Î¶¨Ïä§Ìä∏ Ï§ëÍ∞Ñ ‚Üí Î¶¨Ïä§Ìä∏ Ìï≠Î™© ÏôÑÏÑ±/Ï∂îÍ∞Ä
   - Î¨∏Îã® Ï§ëÍ∞Ñ ‚Üí Î¨∏Ïû• ÏôÑÏÑ±/Ïó∞Í≤∞
   - ÏÑπÏÖò ÎÅù ‚Üí Îã§Ïùå ÏÑπÏÖò ÎòêÎäî ÎÇ¥Ïö© ÌôïÏû•
   - ÌÖåÏù¥Î∏î/ÏΩîÎìúÎ∏îÎ°ù ‚Üí Ìï¥Îãπ ÌòïÏãù Ïú†ÏßÄ
2. **Í∏∞Ï°¥ Î¨∏Ï≤¥ÏôÄ ÌÜ§ÏùÑ ÏôÑÏ†ÑÌûà Ïú†ÏßÄ**ÌïòÎ©∞ ÏûêÏó∞Ïä§ÎüΩÍ≤å Ïù¥Ïñ¥ÏßÄÎäî ÎÇ¥Ïö©ÏùÑ ÏÉùÏÑ±ÌïòÏÑ∏Ïöî
3. **Í∏∞Ï°¥ ÎßàÌÅ¨Îã§Ïö¥ Ìè¨Îß∑ÏùÑ Ï†ïÌôïÌûà Îî∞Îùº**ÌïòÏÑ∏Ïöî (Ìó§Îî© Î†àÎ≤®, Î¶¨Ïä§Ìä∏ ÌòïÏãù, ÍµµÍ∏∞ Îì±)
4. Í∞Å Ï†úÏïàÏùÄ **Í∞ÑÍ≤∞ÌïòÍ≥† ÌïµÏã¨Ï†ÅÏù∏ ÎÇ¥Ïö©**ÏúºÎ°ú ÏûëÏÑ±ÌïòÏÑ∏Ïöî (20-150Ïûê Ï†ïÎèÑ)
5. ÌòÑÏû¨ Î¨∏Îã®/ÏÑπÏÖòÏùò **Ï£ºÏ†úÏôÄ Î™©Ï†ÅÏóê Ï†ïÌôïÌûà ÎßûÎäî** ÎÇ¥Ïö©ÏùÑ Ï†úÏïàÌïòÏÑ∏Ïöî
6. **Ïª§ÏÑú Ïïû ÎßàÏßÄÎßâ Î∂ÄÎ∂ÑÏùò Îß•ÎùΩ**ÏùÑ Ïö∞ÏÑ† Í≥†Î†§ÌïòÏó¨ ÏûêÏó∞Ïä§ÎüΩÍ≤å Ïù¥Ïñ¥ÏßÄÎèÑÎ°ù ÌïòÏÑ∏Ïöî
7. **Î≤àÌôîÌïòÍ±∞ÎÇò Î∂àÌïÑÏöîÌïú ÎÇ¥Ïö©ÏùÄ ÌîºÌïòÍ≥†** ÌïµÏã¨Îßå Í∞ÑÍ≤∞ÌïòÍ≤å ÌëúÌòÑÌïòÏÑ∏Ïöî
8. Ï†ÑÏ≤¥ Î¨∏ÏÑúÏùò **Íµ¨Ï°∞ÏôÄ ÏùºÍ¥ÄÏÑ±**ÏùÑ Í≥†Î†§ÌïòÏó¨ Ï†ÅÏ†àÌïú ÎÇ¥Ïö©ÏùÑ ÏÉùÏÑ±ÌïòÏÑ∏Ïöî
9. **5Í∞ú Ï†ïÎèÑÏùò Îã§ÏñëÌïú Ï†úÏïàÏùÑ Ï†úÍ≥µ**ÌïòÎêò, Î™®Îëê Ïú†Ïö©ÌïòÍ≥† Íµ¨Ï≤¥Ï†ÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§
10. Î∞òÎìúÏãú ÏàúÏàò JSON Î∞∞Ïó¥ ÌòïÌÉúÎ°úÎßå Î∞òÌôòÌïòÏÑ∏Ïöî (ÏΩîÎìú Î∏îÎ°ùÏù¥ÎÇò ÏÑ§Î™Ö ÏóÜÏù¥)

ÏùëÎãµ ÌòïÏãù (Ïù¥ ÌòïÌÉú Í∑∏ÎåÄÎ°ú):
["Ï†úÏïà 1", "Ï†úÏïà 2", "Ï†úÏïà 3", "Ï†úÏïà 4", "Ï†úÏïà 5"]`;
      }

      console.log('\nüì§ AIÏóêÍ≤å Ï†ÑÏÜ°Ìï† ÌîÑÎ°¨ÌîÑÌä∏:');
      console.log('---BEGIN PROMPT---');
      console.log(prompt);
      console.log('---END PROMPT---');
      
      // Î≥ÄÏàò ÏπòÌôò ÌôïÏù∏
      console.log('\nüîç Î≥ÄÏàò ÏπòÌôò ÌôïÏù∏:', {
        ÌîÑÎ°¨ÌîÑÌä∏Í∏∏Ïù¥: prompt.length,
        textÎ≥ÄÏàòÌè¨Ìï®: prompt.includes('{text}'),
        beforeCursorÎ≥ÄÏàòÌè¨Ìï®: prompt.includes('{beforeCursor}'),
        afterCursorÎ≥ÄÏàòÌè¨Ìï®: prompt.includes('{afterCursor}'),
        selectedTextÎ≥ÄÏàòÌè¨Ìï®: prompt.includes('{selectedText}')
      });
      
      console.log('\nü§ñ AI Ìò∏Ï∂ú Ï§ë...', `${provider} (${model})`);
      
      // ÎîîÎ≤ÑÍπÖÏö©: ÌîÑÎ°¨ÌîÑÌä∏ Î≥ÄÏàò ÌôïÏù∏
      if (mode === 'continue') {
        console.log('üìù Ïó∞ÏÜç ÏûëÏÑ± Î™®Îìú ÏÑ∏Î∂Ä Ï†ïÎ≥¥:', {
          Ïª§ÏÑúÏïûÎßàÏßÄÎßâÏ§Ñ: beforeCursor.split('\n').pop(),
          Ïª§ÏÑúÎí§Ï≤´Ï§Ñ: afterCursor.split('\n')[0],
          Î≥ÄÏàòÏπòÌôòÏó¨Î∂Ä: customContinuePrompt ? 'ÏÇ¨Ïö©ÏûêÏ†ïÏùò' : 'Í∏∞Î≥∏'
        });
      } else if (mode === 'improve') {
        console.log('‚ú® Í∞úÏÑ† Î™®Îìú ÏÑ∏Î∂Ä Ï†ïÎ≥¥:', {
          ÏÑ†ÌÉùÎêúÌÖçÏä§Ìä∏: selectedText.slice(0, 100) + (selectedText.length > 100 ? '...' : ''),
          Î≥ÄÏàòÏπòÌôòÏó¨Î∂Ä: customImprovePrompt ? 'ÏÇ¨Ïö©ÏûêÏ†ïÏùò' : 'Í∏∞Î≥∏'
        });
      }

      const completion = await currentOpenai.chat.completions.create({
        model: model,
        messages: [
          { 
            role: "system", 
            content: "ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏Ï†ÅÏù∏ Í∏ÄÏì∞Í∏∞ ÎèÑÍµ¨ÏûÖÎãàÎã§. ÏÇ¨Ïö©ÏûêÏùò ÏöîÏ≤≠Ïóê Îî∞Îùº Ï†ÅÏ†àÌïú Í∞úÏàòÏùò Ï†úÏïàÏùÑ JSON Î∞∞Ïó¥ ÌòïÏãùÏúºÎ°úÎßå ÏùëÎãµÌïòÏÑ∏Ïöî. Îã§Î•∏ Ïñ¥Îñ§ ÌÖçÏä§Ìä∏, ÏÑ§Î™Ö, ÎßàÌÅ¨Îã§Ïö¥ÎèÑ Ìè¨Ìï®ÌïòÏßÄ ÎßàÏÑ∏Ïöî. Ïò§ÏßÅ [\"Ï†úÏïà1\", \"Ï†úÏïà2\", \"Ï†úÏïà3\", \"Ï†úÏïà4\", \"Ï†úÏïà5\"] ÌòïÏãùÏ≤òÎüº ÏàúÏàòÌïú JSON Î∞∞Ïó¥Îßå Î∞òÌôòÌïòÏÑ∏Ïöî." 
          },
          { role: "user", content: prompt + "\n\nÏ§ëÏöî: ÏÇ¨Ïö©ÏûêÍ∞Ä ÌîÑÎ°¨ÌîÑÌä∏ÏóêÏÑú ÏöîÏ≤≠Ìïú Í∞úÏàòÎßåÌÅº Ìï≠Î™©ÏùÑ Í∞ÄÏßÑ JSON Î∞∞Ïó¥Îßå Î∞òÌôòÌïòÏÑ∏Ïöî. Í∞úÏàòÍ∞Ä Î™ÖÏãúÎêòÏßÄ ÏïäÏúºÎ©¥ 3-5Í∞úÎ•º Í∏∞Î≥∏ÏúºÎ°ú ÌïòÎêò, ÌíàÏßàÏùÑ ÏúÑÌï¥ Ïú†Ïö©Ìïú ÎßåÌÅº Ï†úÏïàÌïòÏÑ∏Ïöî." }
        ],
        max_completion_tokens: 1000,
        temperature: 0.3
      });

      const rawResponse = completion.choices[0].message.content;
      console.log('\nüì• AI ÏõêÎ≥∏ ÏùëÎãµ:');
      console.log('---BEGIN RESPONSE---');
      console.log(rawResponse);
      console.log('---END RESPONSE---');
      
      console.log('\nüîç ÏùëÎãµ ÌååÏã± Ï§ë...');

      let suggestions;
      try {
        let responseContent = rawResponse.trim();
        
        console.log('üìä ÏùëÎãµ Ï†ïÎ≥¥:', {
          Í∏∏Ïù¥: responseContent.length,
          ÌÉÄÏûÖ: typeof responseContent,
          Ï≤´100Ïûê: responseContent.substring(0, 100)
        });
        
        // 1. ÎßàÌÅ¨Îã§Ïö¥ ÏΩîÎìú Î∏îÎ°ù Ï†úÍ±∞
        responseContent = responseContent.replace(/^```(?:json)?\s*/gm, '').replace(/\s*```$/gm, '');
        
        // 2. JSON Î∞∞Ïó¥ Ìå®ÌÑ¥ Ï∞æÍ∏∞ (Îçî Í∞ïÎ†•Ìïú Ï†ïÍ∑úÏãù)
        const jsonArrayPattern = /\[\s*"[^"]*"(?:\s*,\s*"[^"]*")*\s*\]/;
        let jsonMatch = responseContent.match(jsonArrayPattern);
        
        if (!jsonMatch) {
          // 3. ÎåÄÏïà: Îçî Ïú†Ïó∞Ìïú Ìå®ÌÑ¥ÏúºÎ°ú ÏãúÎèÑ (Îî∞Ïò¥ÌëúÍ∞Ä ÏÑûÏó¨ÏûàÏùÑ Ïàò ÏûàÏùå)
          const flexiblePattern = /\[[\s\S]*?\]/;
          jsonMatch = responseContent.match(flexiblePattern);
        }
        
        if (jsonMatch) {
          responseContent = jsonMatch[0];
        } else {
          // 4. JSON Î∞∞Ïó¥Ïù¥ ÏóÜÎäî Í≤ΩÏö∞: ÌÖçÏä§Ìä∏ÏóêÏÑú Î¨∏Ïû•ÏùÑ Ï∂îÏ∂úÌï¥ÏÑú Î∞∞Ïó¥Î°ú ÎßåÎì§Í∏∞
          console.log('JSON Ìå®ÌÑ¥ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå. ÌÖçÏä§Ìä∏ÏóêÏÑú Ï∂îÏ∂ú ÏãúÎèÑ...');
          
          // ÌÖçÏä§Ìä∏Î•º Ï§ÑÎ∞îÍøàÏúºÎ°ú Î∂ÑÎ¶¨ÌïòÏó¨ Ï≤òÎ¶¨
          const lines = responseContent.split('\n').filter(line => line.trim().length > 0);
          const extractedSuggestions = [];
          
          for (const line of lines) {
            const cleanLine = line.replace(/^[-*\d\.)\s]+/, '').trim(); // Î¶¨Ïä§Ìä∏ ÎßàÏª§ Ï†úÍ±∞
            if (cleanLine.length > 5 && cleanLine.length < 200) { // Ï†ÅÏ†àÌïú Í∏∏Ïù¥Ïùò Î¨∏Ïû•Îßå
              extractedSuggestions.push(cleanLine);
              if (extractedSuggestions.length >= 3) break;
            }
          }
          
          if (extractedSuggestions.length >= 3) {
            suggestions = extractedSuggestions.slice(0, 3);
          } else {
            throw new Error('ÌÖçÏä§Ìä∏ÏóêÏÑú Ï†ÅÏ†àÌïú Ï†úÏïàÏùÑ Ï∂îÏ∂úÌï† Ïàò ÏóÜÏùå');
          }
        }
        
        // 5. JSON ÌååÏã± ÏãúÎèÑ (ÏúÑÏóêÏÑú Î∞∞Ïó¥ÏùÑ ÎßåÎì§ÏßÄ ÏïäÏùÄ Í≤ΩÏö∞)
        if (!suggestions) {
          console.log('üîç JSON ÌååÏã± ÏãúÎèÑ:', responseContent);
          
          // Î∂àÏôÑÏ†ÑÌïú JSON ÏàòÏ†ï ÏãúÎèÑ
          let fixedJson = responseContent;
          
          // ÎÅùÏù¥ ÏûòÎ¶∞ Í≤ΩÏö∞ ÏàòÏ†ï
          if (!fixedJson.endsWith(']')) {
            const lastQuoteIndex = fixedJson.lastIndexOf('"');
            if (lastQuoteIndex > 0) {
              fixedJson = fixedJson.substring(0, lastQuoteIndex + 1) + ']';
            }
          }
          
          console.log('üîß ÏàòÏ†ïÎêú JSON:', fixedJson);
          suggestions = JSON.parse(fixedJson);
        }
        
        if (!Array.isArray(suggestions) || suggestions.length === 0) {
          throw new Error('Invalid response format');
        }
        
        // ÏµúÎåÄ 10Í∞úÎ°ú Ï†úÌïú (ÎÑàÎ¨¥ ÎßéÏúºÎ©¥ UIÍ∞Ä Î≥µÏû°Ìï¥Ïßê)
        suggestions = suggestions.slice(0, 10);
        
        console.log('\n‚úÖ ÌååÏã± ÏÑ±Í≥µ!');
        
      } catch (parseError) {
        console.log('\n‚ùå JSON ÌååÏã± Ïã§Ìå®:', parseError.message);
        console.log('üîÑ Í∏∞Î≥∏ Ï∂îÏ≤úÏúºÎ°ú ÎåÄÏ≤¥');
        
        // ÌååÏã± Ïã§Ìå® Ïãú Î™®ÎìúÏóê Îî∞Î•∏ Í∏∞Î≥∏ Ï∂îÏ≤ú Ï†úÍ≥µ
        if (mode && mode === 'improve') {
          suggestions = [
            "Îçî Î™ÖÌôïÌïòÍ≤å ÌëúÌòÑ",
            "Íµ¨Ï≤¥Ï†ÅÏù∏ ÏÑ§Î™ÖÏúºÎ°ú Í∞úÏÑ†", 
            "Í∞ÑÍ≤∞ÌïòÍ≥† Ìö®Í≥ºÏ†ÅÏúºÎ°ú ÏàòÏ†ï"
          ];
        } else {
          suggestions = [
            "ÏùÑ Í≥ÑÏÜç ÏûëÏÑ±ÌïòÏÑ∏Ïöî",
            "Ïóê ÎåÄÌïú ÏûêÏÑ∏Ìïú ÏÑ§Î™Ö", 
            "Ïùò Íµ¨Ï≤¥Ï†ÅÏù∏ ÏòàÏãú"
          ];
        }
      }

      console.log('\nüéØ ÏµúÏ¢Ö Ï∂îÏ≤ú Í≤∞Í≥º:');
      console.log('Í∞úÏàò:', suggestions.length);
      console.log('ÎÇ¥Ïö©:', suggestions);
      console.log('=== AI Ï∂îÏ≤ú ÏöîÏ≤≠ ÏôÑÎ£å ===\n');
      
      res.json({ suggestions });
      
    } catch (error) {
      console.log('\nüí• AI Ï∂îÏ≤ú ÏöîÏ≤≠ Ïã§Ìå®:', error.message);
      console.log('=== AI Ï∂îÏ≤ú ÏöîÏ≤≠ ÏôÑÎ£å (Ïã§Ìå®) ===\n');
      
      const errorSuggestions = (mode && mode === 'improve')
        ? ["Îçî Î™ÖÌôïÌïòÍ≤å ÌëúÌòÑ", "Íµ¨Ï≤¥Ï†ÅÏù∏ ÏÑ§Î™Ö Ï∂îÍ∞Ä", "Í∞ÑÍ≤∞ÌïòÍ≤å Ï†ïÎ¶¨"]
        : ["Í≥ÑÏÜç ÏûëÏÑ±ÌïòÍ∏∞...", "Îçî ÏûêÏÑ∏Ìûà ÏÑ§Î™Ö", "ÏòàÏãú Ï∂îÍ∞ÄÌïòÍ∏∞"];
        
      res.status(500).json({ 
        error: 'Failed to generate suggestions',
        suggestions: errorSuggestions
      });
    }
  });

  // === ÌååÏùº Ïû†Í∏à Í¥ÄÎ†® Ìó¨Ìçº Ìï®ÏàòÎì§ ===
  
  // ÌååÏùº Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú
  function loadFileLockMetadata() {
    try {
      if (fs.existsSync(LOCK_METADATA_FILE)) {
        const data = fs.readFileSync(LOCK_METADATA_FILE, 'utf8');
        return JSON.parse(data);
      }
    } catch (error) {
      console.error('ÌååÏùº Ïû†Í∏à Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú Ïò§Î•ò:', error);
    }
    return {};
  }
  
  // ÌååÏùº Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
  function saveFileLockMetadata(metadata) {
    try {
      // PRESET_DIRÏù¥ ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
      if (!fs.existsSync(PRESET_DIR)) {
        fs.mkdirSync(PRESET_DIR, { recursive: true });
      }
      fs.writeFileSync(LOCK_METADATA_FILE, JSON.stringify(metadata, null, 2));
    } catch (error) {
      console.error('ÌååÏùº Ïû†Í∏à Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïò§Î•ò:', error);
    }
  }
  
  // ÎπÑÎ∞ÄÎ≤àÌò∏ Ìï¥Ïãú ÏÉùÏÑ±
  function hashPassword(password, salt) {
    return crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');
  }
  
  // ÎûúÎç§ salt ÏÉùÏÑ±
  function generateSalt() {
    return crypto.randomBytes(32).toString('hex');
  }
  
  // ÌååÏùº ÎÇ¥Ïö© ÏïîÌò∏Ìôî
  function encryptFileContent(content, password) {
    const algorithm = 'aes-256-gcm';
    const key = crypto.scryptSync(password, 'salt', 32);
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(algorithm, key);
    
    let encrypted = cipher.update(content, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return {
      encrypted: encrypted,
      iv: iv.toString('hex')
    };
  }
  
  // ÌååÏùº ÎÇ¥Ïö© Î≥µÌò∏Ìôî
  function decryptFileContent(encryptedData, password) {
    const algorithm = 'aes-256-gcm';
    const key = crypto.scryptSync(password, 'salt', 32);
    const decipher = crypto.createDecipher(algorithm, key);
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }

  // === ÌååÏùº Ïû†Í∏à API ÏóîÎìúÌè¨Ïù∏Ìä∏Îì§ ===
  
  // ÌååÏùº Ïû†Í∏à ÏÉÅÌÉú ÌôïÏù∏
  app.get('/api/check-file-lock', (req, res) => {
    try {
      const { filename } = req.query;
      if (!filename) {
        return res.status(400).json({ error: 'Filename is required' });
      }
      
      const metadata = loadFileLockMetadata();
      const isLocked = metadata[filename] && metadata[filename].isLocked;
      
      res.json({ isLocked: !!isLocked });
    } catch (error) {
      console.error('ÌååÏùº Ïû†Í∏à ÏÉÅÌÉú ÌôïÏù∏ Ïò§Î•ò:', error);
      res.status(500).json({ error: 'Failed to check file lock status' });
    }
  });
  
  // ÌååÏùº Ïû†Í∏à ÏÑ§Ï†ï
  app.post('/api/set-file-lock', (req, res) => {
    try {
      const { filename, password } = req.body;
      
      if (!filename || !password) {
        return res.status(400).json({ error: 'Filename and password are required' });
      }
      
      if (password.length < 4) {
        return res.status(400).json({ error: 'Password must be at least 4 characters' });
      }
      
      const metadata = loadFileLockMetadata();
      const salt = generateSalt();
      const hashedPassword = hashPassword(password, salt);
      
      // ÌååÏùºÏù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥† ÎÇ¥Ïö© ÏùΩÍ∏∞
      const filePath = path.join(PRESET_DIR, filename);
      if (fs.existsSync(filePath)) {
        const content = fs.readFileSync(filePath, 'utf8');
        const encryptedData = encryptFileContent(content, password);
        
        // ÏïîÌò∏ÌôîÎêú ÎÇ¥Ïö©ÏúºÎ°ú ÌååÏùº Ï†ÄÏû•
        fs.writeFileSync(filePath + '.encrypted', JSON.stringify(encryptedData));
        
        // ÏõêÎ≥∏ ÌååÏùº ÏÇ≠Ï†ú (ÏÑ†ÌÉùÏ†Å)
        // fs.unlinkSync(filePath);
      }
      
      // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
      metadata[filename] = {
        isLocked: true,
        passwordHash: hashedPassword,
        salt: salt,
        createdAt: new Date().toISOString(),
        hasEncryptedFile: true
      };
      
      saveFileLockMetadata(metadata);
      
      res.json({ success: true, message: 'File locked successfully' });
    } catch (error) {
      console.error('ÌååÏùº Ïû†Í∏à ÏÑ§Ï†ï Ïò§Î•ò:', error);
      res.status(500).json({ error: 'Failed to set file lock' });
    }
  });
  
  // ÌååÏùº Ïû†Í∏à Ìï¥Ï†ú
  app.post('/api/remove-file-lock', (req, res) => {
    try {
      const { filename } = req.body;
      
      if (!filename) {
        return res.status(400).json({ error: 'Filename is required' });
      }
      
      const metadata = loadFileLockMetadata();
      
      if (metadata[filename]) {
        // ÏïîÌò∏ÌôîÎêú ÌååÏùº ÏÇ≠Ï†ú
        const encryptedFilePath = path.join(PRESET_DIR, filename + '.encrypted');
        if (fs.existsSync(encryptedFilePath)) {
          fs.unlinkSync(encryptedFilePath);
        }
        
        // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú Ï†úÍ±∞
        delete metadata[filename];
        saveFileLockMetadata(metadata);
      }
      
      res.json({ success: true, message: 'File lock removed successfully' });
    } catch (error) {
      console.error('ÌååÏùº Ïû†Í∏à Ìï¥Ï†ú Ïò§Î•ò:', error);
      res.status(500).json({ error: 'Failed to remove file lock' });
    }
  });
  
  // ÌååÏùº Ïû†Í∏à Ìï¥Ï†ú (ÎπÑÎ∞ÄÎ≤àÌò∏Î°ú)
  app.post('/api/unlock-file', (req, res) => {
    try {
      const { filename, password } = req.body;
      
      if (!filename || !password) {
        return res.status(400).json({ error: 'Filename and password are required' });
      }
      
      const metadata = loadFileLockMetadata();
      const fileMetadata = metadata[filename];
      
      if (!fileMetadata || !fileMetadata.isLocked) {
        return res.status(400).json({ error: 'File is not locked' });
      }
      
      // ÎπÑÎ∞ÄÎ≤àÌò∏ Í≤ÄÏ¶ù
      const hashedPassword = hashPassword(password, fileMetadata.salt);
      if (hashedPassword !== fileMetadata.passwordHash) {
        return res.json({ success: false, message: 'Incorrect password' });
      }
      
      // ÏïîÌò∏ÌôîÎêú ÌååÏùº ÎÇ¥Ïö© Î≥µÌò∏Ìôî
      const encryptedFilePath = path.join(PRESET_DIR, filename + '.encrypted');
      if (fs.existsSync(encryptedFilePath)) {
        const encryptedData = JSON.parse(fs.readFileSync(encryptedFilePath, 'utf8'));
        const decryptedContent = decryptFileContent(encryptedData, password);
        
        // Î≥µÌò∏ÌôîÎêú ÎÇ¥Ïö©ÏùÑ ÏõêÎ≥∏ ÌååÏùºÎ°ú Î≥µÏõê
        const originalFilePath = path.join(PRESET_DIR, filename);
        fs.writeFileSync(originalFilePath, decryptedContent);
      }
      
      res.json({ success: true, message: 'File unlocked successfully' });
    } catch (error) {
      console.error('ÌååÏùº Ïû†Í∏à Ìï¥Ï†ú Ïò§Î•ò:', error);
      res.status(500).json({ error: 'Failed to unlock file' });
    }
  });

  app.post('/export-html', async (req, res) => {
    try {
        const { markdown, file } = req.body;
        if (typeof markdown !== 'string') return res.status(400).send('Invalid content.');

        const { md, toc } = createMarkdownParser();
        const templatePath = path.resolve(__dirname, 'template.html');
        const templateContent = fs.readFileSync(templatePath, 'utf8');

        const contentHtml = md.render(markdown);
        const tocHtml = generateTocHtml(toc);

        let finalHtml = templateContent
            .replace('{{TOC_HTML}}', tocHtml)
            .replace('{{CONTENT}}', contentHtml);
        
        // Add a class to the body for HTML export to hide elements via CSS
        // and remove the live-reload script.
        finalHtml = finalHtml
            .replace('<body>', '<body class="export-mode">')
            .replace(
                '</body>', 
                '<script>window.IS_EXPORTED=true;</script></body>'
            );

        const filename = file ? path.basename(file, '.md') + '.html' : 'presentation.html';
        
        res.setHeader('Content-Type', 'text/html');
        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);
        res.send(finalHtml);
    } catch (error) {
        console.error('Error exporting HTML:', error);
        res.status(500).send('Error generating HTML file.');
    }
  });

  app.post('/export-markdown', async (req, res) => {
    try {
        const { markdown, file } = req.body;
        if (typeof markdown !== 'string') return res.status(400).send('Invalid content.');

        const filename = file ? path.basename(file) : 'presentation.md';
        
        res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);
        res.send(markdown);
    } catch (error) {
        console.error('Error exporting Markdown:', error);
        res.status(500).send('Error generating Markdown file.');
    }
  });

  const server = app.listen(port, () => console.log(`Server started on http://localhost:${port}`));
  
  const wss = new WebSocket.Server({ server });
  wss.on('connection', ws => console.log('Client connected for live reload.'));
  const broadcastReload = () => wss.clients.forEach(c => c.readyState === WebSocket.OPEN && c.send('reload'));
  
  chokidar.watch(PRESET_DIR).on('all', (event, path) => {
    if (['add', 'change', 'unlink'].includes(event)) {
      console.log(`${path} has been ${event}`);
      broadcastReload();
    }
  });
}

// --- Main Execution Logic ---

if (options.web) {
  serveApp(options);
} else if (options.md) {
  runCli(options);
} else {
  // If no relevant options are provided, show help.
  program.help();
} 